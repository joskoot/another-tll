#lang racket

(require "interpreter.rkt")

(print-graph #t)

(define (check-sexpr sexpr)
 (or
  (symbol? sexpr)
  (boolean? sexpr)
 ; (natural? sexpr)
  (and (list? sexpr) (andmap check-sexpr sexpr))
  (error 'check-sexpr "not a sexpr ~s" sexpr)))

(define (nr-of-atoms x)
 (define hash (make-hash))
 (define (nr-of-atoms x)
  (let ((n (hash-ref hash x #f)))
   (cond
    (n)
    ((list? x) (let ((n (apply + (map nr-of-atoms x)))) (hash-set! hash x n) n))
    (else (hash-set! hash x 1) 1))))
 (nr-of-atoms x))

(define (reduced-nr-of-atoms x)
 (define hash (make-hash))
 (define (nr-of-atoms x)
  (let ((n (hash-ref hash x #f)))
   (cond
    (n 0)
    ((list? x) (let ((n (apply + (map nr-of-atoms x)))) (hash-set! hash x n) n))
    (else (hash-set! hash x 1) 1))))
 (nr-of-atoms x))

(define (free-vars expr)
 (define free-set (mutable-set))
 (define (add-free! symbol) (set-add! free-set symbol))
 (define (free-vars expr bound-vars)
  (define (bound? symbol) (set-member? bound-vars symbol))
  (define (let*-form? expr)
   (and
    (not (bound? 'let*))
    (list? expr)
    (= (length expr) 3)
    (eq? (car expr) 'let*)
    (bindings? (cadr expr))
    (add-free! 'let*)))
  (define (bindings? expr)
   (and (list? expr) (andmap binding? expr)))
  (define (binding? expr)
   (and (list? expr) (= (length expr) 2) (symbol? (car expr))))
  (define (do-let*-form bindings body bound-vars)
   (cond
    ((null? bindings) (free-vars body bound-vars))
    (else (free-vars (cadar bindings) bound-vars)
     (do-let*-form (cdr bindings) body (set-add bound-vars (caar bindings))))))
  (define (lambda-form? expr)
   (and
    (not (bound? 'lambda))
    (list? expr)
    (= (length expr) 3)
    (eq? (car expr) 'lambda)
    (formals? (cadr expr))
    (add-free! 'lambda)))
  (define (formals? lst) (and (list? lst) (andmap symbol? lst)))
  (define (do-lambda-form formals body set)
   (free-vars body (set-union bound-vars (apply seteq formals))))
  (define (quote-form? expr)
   (and
    (list? expr)
    (= (length expr) 2)
    (eq? (car expr) 'quote)
    (not (bound? 'quote))
    (add-free! 'quote)))
  (cond
   ((symbol? expr) (unless (bound? expr) (add-free! expr)))
   ((let*-form? expr) (do-let*-form (cadr expr) (caddr expr) bound-vars))
   ((lambda-form? expr) (do-lambda-form (cadr expr) (caddr expr) bound-vars))
   ((quote-form? expr))
   ((list? expr) (for ((elem (in-list expr))) (free-vars elem bound-vars)))
   (else (void))))
 (free-vars expr (seteq))
 (sort (set->list free-set) symbol<?))

(define (depth expr)
 (define h (make-hash))
 (define (depth expr)
  (cond
   ((hash-ref h expr #f))
   ((and (pair? expr) (list? expr))
    (let ((n (add1 (apply max (map depth expr))))) (hash-set! h expr n) n))
   (else (hash-set! h expr 0) 0)))
 (depth expr))

(define (sexpr? obj)
 (define h (make-hash))
 (define (sexpr? obj)
  (or (hash-ref h obj #f)
   (and (hash-set! h obj #t)
    (or (atom? obj) (and (pair? obj) (andmap sexpr? obj))))))
 (sexpr? obj))

(define (atom? obj)
 (or
  (symbol? obj)
  (boolean? obj)
  (null? obj)))

(define |(value source-code)| (value source-code))
(define nr-of-atoms-source (nr-of-atoms source-code))
(define nr-of-atoms-value-source (nr-of-atoms |(value source-code)|))

(newline)
(printf "Is the source-code a sexpr? ~s~n" (check-sexpr source-code))
(printf "Is (value source-code) a sexpr? ~s~n" (sexpr? |(value source-code)|))
(printf "Nr of atoms in source-code: ~s~n" nr-of-atoms-source)
(printf "Nr of distinct atoms in source-code: ~s~n" (reduced-nr-of-atoms source-code))
(printf "Nr of atoms in (value source-code): ~s~n" nr-of-atoms-value-source)
(printf "Nr of distinct atoms in (value source-code): ~s~n"
 (reduced-nr-of-atoms |(value source-code)|))
(printf "Depth source-code: ~s~n" (depth source-code))
(printf "Depth (value source-code): ~s~n" (depth |(value source-code)|))
(printf "Free variables (+ macros): ~s~n" (free-vars source-code))
(printf "~n(value source-code):~n~n")
(parameterize ((print-graph #t)) (~s |(value source-code)|))
